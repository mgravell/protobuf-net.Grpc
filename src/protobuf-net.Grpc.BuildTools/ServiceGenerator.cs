using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Diagnostics;
using Microsoft.CodeAnalysis.VisualBasic.Syntax;
using System.Collections.Immutable;
using System.Text;
using CSharpKind = Microsoft.CodeAnalysis.CSharp.SyntaxKind;
using VBKind = Microsoft.CodeAnalysis.VisualBasic.SyntaxKind;

namespace ProtoBuf.Grpc.BuildTools;

[Generator(LanguageNames.CSharp, LanguageNames.VisualBasic)]
[DiagnosticAnalyzer(LanguageNames.CSharp, LanguageNames.VisualBasic)]
public sealed class ServiceGenerator : DiagnosticAnalyzer, IIncrementalGenerator
{
    public const string CodegenNamespace = "ProtoBuf.Grpc.AOT";
    public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics => ImmutableArray<DiagnosticDescriptor>.Empty;

    public event Action<string>? Log;

    [System.Diagnostics.CodeAnalysis.SuppressMessage("MicrosoftCodeAnalysisCorrectness", "RS1026:Enable concurrent execution", Justification = "Done in release")]
    public override void Initialize(AnalysisContext context)
    {
#if !DEBUG
        context.EnableConcurrentExecution();
#endif
        context.ConfigureGeneratedCodeAnalysis(GeneratedCodeAnalysisFlags.None);
    }

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var nodes = context.SyntaxProvider.CreateSyntaxProvider(PreFilter, Parse)
            .Where(x => x is not null)
            .Select((x, _) => x!);
        var combined = context.CompilationProvider.Combine(nodes.Collect());
        context.RegisterImplementationSourceOutput(combined, Generate);
    }

    // fail-fast check to exclude irrelevant nodes
    private bool PreFilter(SyntaxNode node, CancellationToken token) => (node.IsKind(CSharpKind.InterfaceDeclaration) && node is InterfaceDeclarationSyntax)
            || (node.IsKind(VBKind.InterfaceStatement) && node is InterfaceStatementSyntax);

    private static readonly object Missing = null!;

    // minimal scan and validate of the object to a model that is detached from the Roslyn core (for GC reasons)
    private object Parse(GeneratorSyntaxContext context, CancellationToken token)
    {
        try
        {
            var symbol = context.SemanticModel.GetDeclaredSymbol(context.Node, token);
            if (symbol is not null)
            {
                Log?.Invoke($"Parsing {symbol.Kind} {symbol.Name}");

                var parsed = Service.TryCreate(symbol);
                if (parsed is not null)
                {
                    Log?.Invoke($"Parsed; {parsed.Flags}");
                    return parsed;
                }
            }
        }
        catch (Exception ex)
        {
            // don't scream errors at the IDE
            Log?.Invoke(ex.Message);
        }
        return Missing;
    }

    // actual thinking
    private void Generate(SourceProductionContext context, (Compilation Left, ImmutableArray<object> Right) tuple)
    {
        try
        {
            Log?.Invoke($"Generating from {tuple.Right.Length} values");

            List<Service>? services = null;
            var syntaxTrees = tuple.Left.SyntaxTrees;
            foreach (var obj in tuple.Right)
            {
                if (obj is Service svc)
                {
                    if (svc.IsInvalid)
                    {
                        context.ReportDiagnostic(Diagnostic.Create(Diagnostics.InvalidService, svc.Location.GetLocation(syntaxTrees)));
                    }
                    else
                    {
                        (services ??= []).Add(svc);
                    }
                }
            }

            if (services is null)
            {
                Log?.Invoke("No valid services detected; nothing to do");
                return;
            }

            Log?.Invoke($"{services.Count} services detected; generating");
            var sb = new StringBuilder();
            sb.AppendLine("// generated by protobuf-net.Grpc");
            foreach (var ns in services.GroupBy(static svc => svc.Namespace))
            {
                if (!string.IsNullOrWhiteSpace(ns.Key))
                {
                    sb.AppendLine($"// namespace {ns.Key}");
                    sb.AppendLine("// {");
                }
                foreach (var svc in ns)
                {
                    sb.AppendLine($"// {svc.Name} {svc.Flags}");
                    foreach (var op in svc.Operations)
                    {
                        sb.AppendLine($"// - {op.Name} {op.Flags}");
                        foreach (var p in op.Parameters)
                        {
                            sb.AppendLine($"//   - <= {op.Return.Name} {op.Return.Kind} {op.Return.Flags}");
                            sb.AppendLine($"//   - @{p.Name} {p.Kind} {p.Flags}");
                        }
                    }
                }
                if (!string.IsNullOrWhiteSpace(ns.Key))
                {
                    sb.AppendLine("// }");
                }
            }

            Log?.Invoke("Adding generator output");
            context.AddSource("protobuf-net.Grpc.generated.cs", sb.ToString());
        }
        catch (Exception ex)
        {
            Log?.Invoke("Generation failed: " + ex.Message);
        }
    }
}
